---
title: "Population structure"
date: "`r Sys.Date()`"
output: 
    github_document:
        toc: true
---

This directory contains population structure results. The script 
`population-structure.Rmd` renders this `README` and is responsible for creating
the relevant outputs.

```{r setup, include=FALSE, echo=FALSE}
knitr::opts_chunk$set(
    echo = FALSE, message = FALSE, 
    warning = FALSE, error = FALSE,
    fig.height = 10, fig.width = 10, fig.dpi=300,
    out.width = "100%"
)

suppressPackageStartupMessages({
    library(paletteer)
    library(tidyverse)
    library(patchwork)
    library(here)
    library(gt)
    library(fs)
    library(SeqArray)
    library(SNPRelate)
})

theme_set(theme_bw())

pop_levels <- c(
    "Shark Bay" ,"Exmouth Gulf", "Pilbara", 
    "Broome", "North Kimberley", "Scott Reef", "Ashmore", "Heywood Shoal",
    "Gulf of Carpentaria", "North QLD", "South QLD", "New Caledonia"
)

PAL <- c(
    "#DCB0F2FF","#F89C74FF", "#F6CF71FF", "#66C5CCFF","#FE88B1FF", "#87C55FFF",
    "#B497E7FF", "#B3B3B3FF", "#C9DB74FF", "#9EB9F3FF", "#D3B484FF", "#8BE0A4FF"
)
names(PAL) <- c(
    "Shark Bay", "Exmouth Gulf", "Pilbara", 
    "Broome", "Scott Reef", "Ashmore",
    "Heywood Shoal", "North Kimberley", "Gulf of Carpentaria", 
    "North QLD", "South QLD", "New Caledonia"
)

# Custom ordering of colour palette
PALST <- c("#1982c4", "#1982c470", "#1982c430", "grey90", "grey70", "grey50")
names(PALST) <- 1:6

# Set the populations
wa_pops <- c("Shark Bay", "Exmouth Gulf", "Pilbara", "Broome", "North Kimberley")

pops <- fs::dir_ls(here("data", "popmaps"), glob = "*.txt") |>
    read_delim(
        delim = " ", 
        col_names = c("sample", "population"), 
        col_types = cols(), 
        id = "species"
    ) |>
    mutate(
        population = str_replace_all(population, "_", " "),
        species = str_remove(basename(species), "-.*"),
        population = factor(population, levels = names(PAL))
    )

wa_samples <- pops |>
    filter(population %in% wa_pops) |>
    pull(sample)

popmap_lat_long <- fs::dir_ls(
    here("data", "popmaps", "popmaps-lat-long"), 
    glob = "*.csv"
) |>
    purrr::map(read_csv, col_types = cols(), col_select = 1:7) |>
    bind_rows() |>
    unite(col = "sample", sep = "-", species, id, targetid) |>
    mutate(sample = str_replace_all(sample, " ", "-"))
```

```{r helper-functions, echo=FALSE}
.plot_pca <- function(obj, species, grp) {
    pc1_min_max <- range(pretty(range(obj[[species]][[grp]]$pca$V1), n = 5))
    pc2_min_max <- range(pretty(range(obj[[species]][[grp]]$pca$V2), n = 5))
    var <- obj[[species]][[grp]]$variance[c(1,2)]
    
    spc <- case_when(
        species == "ALA" ~ "Aipysurus laevis",
        species == "HMA" ~ "Hydrophis major",
        species == "HST" ~ "Hydrophis stokesii",
        .default = "Unknown"
    )
    
    obj[[species]][[grp]]$pca |>
        ggplot(
            aes(
                x = V1, y = V2,
                colour = population
            )
        ) +
        geom_point(size = 2.5, show.legend = TRUE) +
        scale_colour_manual(
            values = PAL,
            drop = FALSE
        ) +
        labs(
            title = glue::glue("{spc}"),
            colour = "Population",
            x = glue::glue("PC1 ({var[1]}%)"),
            y = glue::glue("PC2 ({var[2]}%)")
        ) +
        scale_x_continuous(
            limits = c(pc1_min_max[1], pc1_min_max[2]),
            breaks = scales::breaks_pretty(n = 5),
            expand = c(0.01, 0)
        ) +
        scale_y_continuous(
            limits = c(pc2_min_max[1], pc2_min_max[2]),
            breaks = scales::breaks_pretty(n = 5),
            expand = c(0.01, 0)
        ) +
        theme(
            axis.text = element_text(size = 14),
            axis.title = element_text(size = 14),
            legend.position = "bottom",
            legend.title = element_text(hjust = 0.5, size = 14),
            legend.title.position = "top",
            legend.text = element_text(size = 14),
            plot.title = element_text(hjust = 0.5, face = "bold.italic")
        )
}

plot_pca <- function(obj){
    plots <- obj |>
        imap(\(x, i) {
            plot_all <- .plot_pca(obj = obj, species = i, grp = "all")
            plot_wa <- .plot_pca(obj = obj, species = i, grp = "wa")
            list("all" = plot_all, "wa" = plot_wa)
        })
    
    return(plots)
}

# STRUCTURE plotting
my_plot_structure <- function(dat, spec, k, cond, pal_pop, pal_k) {
    
    colour_bar <- dat |>
        filter(species == spec, K == k, condition == cond) |>
        select(sample, population, species) |>
        distinct() |>
        mutate(size = 1) |>
        ggplot(aes(x = sample, y = size, fill = population)) +
        geom_col(width = 1, show.legend = TRUE) +
        scale_fill_manual(values = pal_pop, drop = FALSE) +
        scale_y_continuous(expand = c(0,0)) +
        labs(x = NULL) + 
        theme(
            axis.text.y = element_blank(),
            axis.title.y = element_blank(),
            axis.ticks.y = element_blank(),
            axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0.98),
        ) +
        theme(
            legend.position = "top",
            legend.title = element_blank()
        )
    
    columns <- dat |>
        filter(species == spec, K == k, condition == cond) |>
        ggplot(aes(x = sample, y = proportion, fill = partition)) +
        geom_col(position = "stack", show.legend = TRUE) +
        scale_fill_manual(values = pal_k, drop = FALSE) +
        scale_y_continuous(
            limits = c(0, 1.001),
            breaks = scales::pretty_breaks(n = 5),
            expand = c(0, 0)
        ) +
        labs(x = NULL) +
        guides(fill = guide_legend(title.position = "bottom")) +
        theme(
            axis.title.y = element_blank(),
            axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 0.98),
            legend.position = "bottom",
            legend.title = element_text(hjust = 0.5),
            strip.text.x = element_text(
                face = "bold",
                hjust = 0.5,
                size = 14,
                angle = 90
            ),
            strip.text.y = element_text(size = 14, hjust = 0.5),
            strip.background = element_rect(fill='transparent', colour = NA),
            panel.spacing.x = unit(0.4, "line"),
            panel.grid.major = element_blank(),
            panel.grid.minor = element_blank()
        )
    
    structure_plot <- colour_bar / columns +
        plot_layout(heights = c(1,4), axes = "collect") &
        theme(
            axis.text.x = element_blank(),
            axis.ticks.x = element_blank()
        )    
    
    structure_plot
}
```

## PCA

Below we use `SNPRelate` to perform principal component analysis (PCA). The
VCF files have already been filtered for problem samples, on MAF and LD. Below
we simply make the PCA figures.

```{r make-gds-for-clean-vcfs}
dir_ls(
    here("results", "variant-filtering"),
    glob = "*.vcf.gz"
) |>
    walk(\(x){
        fgds <- paste0(str_remove(x, "\\..*"), ".int.gds")
        fgds_sa <- paste0(str_remove(x, "\\..*"), ".gds")
        
        snpgdsVCF2GDS(vcf.fn = as.character(x), out.fn = fgds, verbose = FALSE) # intermediate - handles our VCF file
        seqSNP2GDS(fgds, fgds_sa, storage.option = "LZMA_RA", verbose = FALSE)
        fs::file_delete(path = fgds)
    })

gds_files <- fs::dir_ls(
    here("results", "variant-filtering"),
    glob = "*.gds"
) |>
    as.character() |>
    (\(x) set_names(x, str_remove(basename(x), "-ld.*")))()

pca_data <- gds_files |>
    (\(x) x[names(x) != "HST-wa"])() |>
    imap(\(x, i) {
        gds <- seqOpen(x)
        sample_ids <- seqGetData(gds, "sample.id")
        sample_ids_wa <- sample_ids[sample_ids %in% wa_samples]
        pca_all <- snpgdsPCA(
            gds,
            autosome.only = FALSE,
            maf = NaN,
            num.thread = 4,
            verbose = FALSE
        )
        var_all <- round(pca_all$varprop*100, 2)
        
        pc_all <- as_tibble(pca_all$eigenvect) |>
            mutate(sample = pca_all$sample.id, .before = V1) |>
            select(sample, V1, V2) |>
            left_join(pops, by = join_by(sample)) |>
            mutate(condition = "All")
        
        
        pca_wa <- snpgdsPCA(
            gds,
            autosome.only = FALSE,
            maf = NaN,
            num.thread = 4,
            verbose = FALSE,
            sample.id = sample_ids_wa
        )
        var_wa <- round(pca_wa$varprop*100, 2)
        
        pc_wa <- as_tibble(pca_wa$eigenvect) |>
            mutate(sample = pca_wa$sample.id, .before = V1) |>
            select(sample, V1, V2) |>
            left_join(pops, by = join_by(sample)) |>
            mutate(condition = "All")
        
        seqClose(gds)
        
        return(
            list(
                "all" = list("pca" = pc_all, "variance" = var_all),
                "wa" = list("pca" = pc_wa, "variance" = var_wa)
            )
        )
    })
```

We'll also process the WA *Hydrophis stokesii* results separately, as these data
are stored in a separate VCF file.

```{r pca-wa-hst}
pca_data_wa_hst <- gds_files |>
    (\(x) x[names(x) == "HST-wa"])() |>
    imap(\(x, i) {
        gds <- seqOpen(x)
        sample_ids <- seqGetData(gds, "sample.id")
        sample_ids_wa <- sample_ids[sample_ids %in% wa_samples]
        pca_all <- snpgdsPCA(
            gds,
            autosome.only = FALSE,
            maf = NaN,
            num.thread = 4,
            verbose = FALSE
        )
        var_all <- round(pca_all$varprop*100, 2)
        
        pc_all <- as_tibble(pca_all$eigenvect) |>
            mutate(sample = pca_all$sample.id, .before = V1) |>
            select(sample, V1, V2) |>
            left_join(pops, by = join_by(sample)) |>
            mutate(condition = "All")
        
        
        pca_wa <- snpgdsPCA(
            gds,
            autosome.only = FALSE,
            maf = NaN,
            num.thread = 4,
            verbose = FALSE,
            sample.id = sample_ids_wa
        )
        var_wa <- round(pca_wa$varprop*100, 2)
        
        pc_wa <- as_tibble(pca_wa$eigenvect) |>
            mutate(sample = pca_wa$sample.id, .before = V1) |>
            select(sample, V1, V2) |>
            left_join(pops, by = join_by(sample)) |>
            mutate(condition = "All")
        
        seqClose(gds)
        
        return(
            list(
                "all" = list("pca" = pc_all, "variance" = var_all),
                "wa" = list("pca" = pc_wa, "variance" = var_wa)
            )
        )
    })

# Overwrite the WA results for HST
pca_data$HST$wa <- pca_data_wa_hst$`HST-wa`$wa
```

### All samples

```{r pca-ALA}
pca_plots <- plot_pca(pca_data)

design <- "12\n34"
plot_pca_all <- (pca_plots$ALA$all + pca_plots$HST$all + pca_plots$HMA$all + guide_area()) +
    plot_layout(
        design = design,
        guides = "collect",
        axes = "collect"
    ) +
    plot_annotation(tag_levels = 'A') &
    guides(colour = guide_legend(ncol = 2, override.aes = list(size = 3))) &
    theme(plot.tag = element_text(size = 14, face = "bold"))

ragg::agg_png(
    filename = here("results", "population-structure", "pca-all-species-all-pops.png"),
    width = 1500,
    height = 1500,
    units = "px",
    res = 150
)
plot_pca_all
invisible(dev.off())

plot_pca_all
```

### WA Coast

And the same for *just* the WA coastline samples

```{r}
plot_pca_wa <- (pca_plots$ALA$wa + pca_plots$HST$wa + pca_plots$HMA$wa + guide_area()) +
    plot_layout(
        design = design,
        guides = "collect",
        axes = "collect"
    ) +
    plot_annotation(tag_levels = 'A') &
    guides(colour = guide_legend(ncol = 2, override.aes = list(size = 3))) &
    theme(plot.tag = element_text(size = 14, face = "bold"))

ragg::agg_png(
    filename = here("results", "population-structure", "pca-all-species-WA-pops.png"),
    width = 1500, 
    height = 1500,
    units = "px",  
    res = 150
)
plot_pca_wa
invisible(dev.off())

plot_pca_wa
```

We can see that the Shark Bay samples partition off in both *A. laevis* and
*H. major*.

## STRUCTURE

`STRUCTURE` analyses were run on the filtered VCF files for a range of `K` values
for both all populations ($2\leq\text{K}\leq10$), and WA populations
only ($2\leq\text{K}\leq5$).

```{r read-structure}
structure_df <- dir_ls(
    here("results", "population-structure", "structure"), 
    glob = "*plot.csv", 
    recurse = TRUE
) |>
    (\(x) set_names(x, str_remove(basename(x), "-burnin.*")))() |>
    map(\(x) {
        tmp <- x |>
            read_csv(col_names = TRUE, col_types = cols())
        tmp |>
            mutate(K = glue::glue("K{ncol(tmp) - 1}")) |>
            pivot_longer(names_to = "partition", values_to = "proportion", 2:ncol(tmp)) |>
            mutate(partition = as.numeric(partition) + 1) |>
            rename(sample = `...1`) |>
            left_join(pops, by = join_by(sample)) |>
            left_join(popmap_lat_long, by = join_by(sample))
    }) |>
    list_rbind(names_to = "condition") |>
    mutate(
        condition = ifelse(str_detect(condition, "all"),"All", "WA"),
        partition = forcats::fct_inorder(as.character(partition)),
        population = str_replace_all(population, "_", " "),
        # population = factor(population, levels = structure_pops),
        .by = K
    ) |>
    arrange(species, longitude) |>
    mutate(
        sample = forcats::fct_inorder(sample),
        population = forcats::fct_inorder(population),
        K = factor(K, levels = paste0("K", 2:10))
    )
```

### Choosing the correct K (N-ancestral populations)

Choosing the best `K` value can be determined by plotting the estimated
log-probability for each `K` value, in addition to the delta-K value. The values
can be interpreted as follows:

- **Estimated log-probability**: Higher values equal better model fit.
- **Delta-K**: The rate of change between successive K-values. Larger values
indicate greater change in the model fit.

The results for the three species are shown below.

```{r}
etable <- dir_ls(
    here("results", "population-structure", "structure"), 
    glob = "*etable.csv",
    recurse = TRUE
) |>
    read_csv(col_names = TRUE, col_types = cols(), id = "species") |>
    mutate(species = str_remove(basename(species), "-burnin.*")) |>
    separate_wider_delim(cols = species, delim = "_", names = c("species", "condition")) |>
    rename(K = `...1`)

max_estln <- etable |> 
    group_by(species, condition) |>
    arrange(desc(estLnProbMean)) |>
    slice(1)

etable |>
    gt(groupname_col = "species") |>
    fmt_number(
        columns = c("K", "Nreps"),
        drop_trailing_zeros = TRUE
    ) |>
    fmt_number(
        columns = 5:9,
        n_sigfig = 4
    )
```

Plotting the table above looks like the following.

```{r}
prb <- etable |>
    ggplot(aes(x = K, y = estLnProbMean, colour = species)) +
    geom_point() +
    geom_line() +
    geom_point(
        data = max_estln,
        aes(x = K, y = estLnProbMean),
        colour = "black",
        size = 3
    ) +
    scale_y_continuous(
        name = "Estimated mean log-probability",
        breaks = scales::pretty_breaks(n = 10),
        labels = scales::label_number(style_negative = "minus")
    ) +
    scale_x_continuous(breaks = seq(2, 10, 1)) +
    facet_wrap(vars(condition), scales = "free_x") +
    scale_colour_brewer(palette = "Set1")

dk <- etable |>
    ggplot(aes(x = K, y = deltaK, colour = species)) +
    geom_point() +
    geom_line() +
    scale_x_continuous(breaks = seq(2, 10, 1)) +
    scale_y_continuous(
        name = "Delta-K",
        breaks = seq(0, 2, 0.25),
        limits = c(0, 2)
    ) +
    facet_wrap(vars(condition), scales = "free_x") +
    scale_colour_brewer(palette = "Set1")

plot_models <- prb/dk +
    plot_layout(axes = "collect", guides = "collect")

ragg::agg_png(
    filename = here("results", "population-structure", "structure-model-fit.png"),
    width = 1000, 
    height = 800,
    units = "px",  
    res = 150
)
plot_models
invisible(dev.off())

plot_models
```

### *Aipysurus laevis*

#### All populations

The `estLnMeanProb` and `Delta-K` values don't quite coincide. We know from the
PCA there are five broad groups (which matches the `estLnMeanProb` value), even
though the `Delta-K` value suggests $\text{K}=3$ is where there is the biggest
rate of change. Granted, other `K` values show some significant peaks and
troughs.

Plotting $\text{K}=3$

```{r ALA-STRUCTURE-ALL-K3}
ala_structure_all_k3 <- my_plot_structure(
    dat = structure_df, 
    spec = "ALA", 
    k = "K3", 
    cond = "All", 
    pal_pop = PAL, 
    pal_k = PALST
)

ala_structure_all_k3
```

And plotting $\text{K}=5$ as in the PCA.

```{r ALA-STRUCTURE-ALL}
ala_structure_all_k5 <- my_plot_structure(
    dat = structure_df, 
    spec = "ALA", 
    k = "K5", 
    cond = "All", 
    pal_pop = PAL, 
    pal_k = PALST
)

ragg::agg_png(
    filename = here("results", "population-structure", "structure-ALA_All-K5.png"),
    width = 1500, 
    height = 1000,
    units = "px",  
    res = 150
)
ala_structure_all_k5
invisible(dev.off())

ala_structure_all_k5
```

#### WA populations

From the PCA, we can see that Shark Bay samples appear to cluster separately to
the rest of the WA populations. The $\text{K} = 3$ model shows the highest `Delta-K`,
however, it really looks like there are two populations - Shark Bay and the rest.

When we plot $\text{K} = 2$, there's not really any discernable difference bewteen
Shark Bay and the remaining populations.

```{r ALA-STRUCTURE-WA-K2}
ala_structure_wa_k2 <- my_plot_structure(
    dat = structure_df, 
    spec = "ALA", 
    k = "K2", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)

ala_structure_wa_k2
```

When we plot $\text{K} = 3$, we can see that the Shark Bay samples have a larger
portion of $\text{K} = 1$ than the other populations.

```{r ALA-STRUCTURE-WA-K3}
ala_structure_wa_k3 <- my_plot_structure(
    dat = structure_df, 
    spec = "ALA", 
    k = "K3", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)

ala_structure_wa_k3
```

This unique population portion is even more evident when plotting $\text{K} = 4$

```{r ALA-STRUCTURE-WA-K4}
ala_structure_wa_k4 <- my_plot_structure(
    dat = structure_df, 
    spec = "ALA", 
    k = "K4", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)

ragg::agg_png(
    filename = here("results", "population-structure", "structure-ALA_WA-K4.png"),
    width = 1500, 
    height = 1000,
    units = "px",  
    res = 150
)
ala_structure_wa_k4
invisible(dev.off())

ala_structure_wa_k4
```

### *Hydrophis major*

#### All populations

The PCA for *H. major* indicates that there could be five broad populations
of snake. The `Delta-K` peak for *H. major* is $\text{K}=3$, though there is
a second peak at $\text{K}=5$ with a significant drop-off after this.

```{r HMA-STRUCTURE-ALL-K3}
hma_structure_all_k3 <- my_plot_structure(
    dat = structure_df, 
    spec = "HMA", 
    k = "K3", 
    cond = "All", 
    pal_pop = PAL, 
    pal_k = PALST
)
hma_structure_all_k3
```

Increasing to $\text{K}=5$ highlights the unique population structure of Shark
Bay, in addition to samples in the Gulf of Carpentaria and South Queensland.

```{r HMA-STRUCTURE-ALL-K5}
hma_structure_all_k5 <- my_plot_structure(
    dat = structure_df, 
    spec = "HMA", 
    k = "K5", 
    cond = "All", 
    pal_pop = PAL, 
    pal_k = PALST
)

ragg::agg_png(
    filename = here("results", "population-structure", "structure-HMA_All-K5.png"),
    width = 1500, 
    height = 1000,
    units = "px",  
    res = 150
)
hma_structure_all_k5
invisible(dev.off())

hma_structure_all_k5
```

#### WA populations

The peak `estLnMeanProb` peaks at $\text{K}=3$, while `Delta-K` shows peaks
at $\text{K}=3$ and $\text{K}=4$, with a significant fall-off after the latter.

The $\text{K}=3$ plot clearly shows Shark Bay as comprising unique population
structure.

```{r HMA-STRUCTURE-WA-K3}
hma_structure_wa_k3 <- my_plot_structure(
    dat = structure_df, 
    spec = "HMA", 
    k = "K3", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)

ragg::agg_png(
    filename = here("results", "population-structure", "structure-HMA_WA-K3.png"),
    width = 1500, 
    height = 1000,
    units = "px",  
    res = 150
)
hma_structure_wa_k3
invisible(dev.off())

hma_structure_wa_k3
```

Increasing $\text{K}=4$ results in two Shark Bay samples having a significant
portion of a unique population `K=3`.

```{r HMA-STRUCTURE-WA-K4}
hma_structure_wa_k4 <- my_plot_structure(
    dat = structure_df, 
    spec = "HMA", 
    k = "K4", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)

hma_structure_wa_k4
```

### *Hydrophis stokesii*

#### All populations

STRUCTURE models that there is likely between 3-5 genetic groups in *H. stokesii*.

```{r HST-STRUCTURE-ALL-K3}
hst_structure_all_k3 <- my_plot_structure(
    dat = structure_df, 
    spec = "HST", 
    k = "K3", 
    cond = "All", 
    pal_pop = PAL, 
    pal_k = PALST
)

hst_structure_all_k3
```

```{r HST-STRUCTURE-ALL-K4}
hst_structure_all_k4 <- my_plot_structure(
    dat = structure_df, 
    spec = "HST", 
    k = "K4", 
    cond = "All", 
    pal_pop = PAL, 
    pal_k = PALST
)

hst_structure_all_k4
```

```{r HST-STRUCTURE-ALL-K5}
hst_structure_all_k5 <- my_plot_structure(
    dat = structure_df, 
    spec = "HST", 
    k = "K5", 
    cond = "All", 
    pal_pop = PAL, 
    pal_k = PALST
)

ragg::agg_png(
    filename = here("results", "population-structure", "structure-HST_All-K5.png"),
    width = 1500, 
    height = 1000,
    units = "px",  
    res = 150
)
hst_structure_all_k5
invisible(dev.off())

hst_structure_all_k5
```

#### WA populations

Interestingly, `Delta-K` and `estLnMeanProb` values suggest there are three
population groups in *H. stokesii* even though the PCA shows a homogeneous
cluster.

Plotting $\text{K}=2$ - $\text{K}=4$ illustrates that STRUCTURE seems to simply
be overfitting and making population groups when there are none. 

```{r HST-STRUCTURE-WA-K2}
hst_structure_wa_k2 <- my_plot_structure(
    dat = structure_df, 
    spec = "HST", 
    k = "K2", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)

ragg::agg_png(
    filename = here("results", "population-structure", "structure-HST_WA-K2.png"),
    width = 1500, 
    height = 1000,
    units = "px",  
    res = 150
)
hst_structure_wa_k2
invisible(dev.off())

hst_structure_wa_k2
```

```{r HST-STRUCTURE-WA-K3}
hst_structure_wa_k3 <- my_plot_structure(
    dat = structure_df, 
    spec = "HST", 
    k = "K3", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)
```

```{r HST-STRUCTURE-WA-K4}
hst_structure_wa_k4 <- my_plot_structure(
    dat = structure_df, 
    spec = "HST", 
    k = "K4", 
    cond = "WA", 
    pal_pop = PAL, 
    pal_k = PALST
)
```

## Isolation by Distance (IBD)

Lastly, we'll perform Isolation-by-distance analysis. We'll first load the VCF
data and estimate the genetic distance matrix (Nei's genetic distance).

Note: I also found this repo helpful - https://github.com/jdalapicolla/IBD_models.R
In addition to this repository - https://anon0433.github.io/strong-individual-signatures/mantel_tests_and_spatial_autocorrelation#figure_4:_mantel-based_correlogram

```{r}
# Load the snpR library and the custom scripts (found in the scripts directory)
library(snpR)
library(marmap)
library(fossil)
library(vegan)
source(here("scripts", "snpR-edited.R"))

# Load updated lat/long popmaps
set.seed(123)
meta_latLong <- popmap_lat_long |>
    mutate(pop = str_replace_all(pop, "_", " ")) |>
    filter(pop %in% wa_pops, !is.na(latitude), !is.na(longitude)) |>
    select(sampID = sample, pop, y = latitude, x = longitude) |>
    mutate(
        pop = str_replace_all(pop, " ", "_"),
        species = case_when(
            str_starts(sampID, "HMA") ~ "HMA",
            str_starts(sampID, "HST") ~ "HST",
            .default = "ALA"
        ),
        .before = sampID
    )

meta_latLong <- split(meta_latLong, meta_latLong$species)

# Load the VCF files as snpR data objects
vcfs <- fs::dir_ls(
    here("results", "variant-filtering"),
    glob = "*vcf.gz",
    recurse = TRUE
) |>
    (\(x) x[str_detect(x, "HST-ld", negate = TRUE)])() |>
    (\(x) set_names(x, str_remove(basename(x), "-.*")))() |> 
    imap(\(v,i) {
        tmp_vcf <- read_vcf(file = v)
        
        # Subset for samples to keep + add in metadata
        tmp_vcf <- subset_snpR_data(
            x = tmp_vcf, 
            .facets = "sampID",
            .subfacets = meta_latLong[[i]]$sampID
        )
        
        sample.meta(tmp_vcf) <- left_join(sample.meta(tmp_vcf), meta_latLong[[i]])
        
        tmp_vcf <- custom_calc_genetic_distances(
            tmp_vcf, 
            facets = c("sampID", "pop"), 
            method = "Nei"
        )
        tmp_vcf
    })
```

### Mantel statistics and spatial auto-correlation

Next we'll perform the Mantel tests and generate the autocorrelation plots. We're
using `vegan` to perform Mantel tests as this package has the autocorrelation
function as well. Consequently, we're not using the in-built IBD function in
`snpR`.

```{r mantel-tests}
mantel_results <- vcfs |>
    imap(\(x, i) {
        genMat <- get.snpR.stats(x, facets = "sampID", stats = "genetic_distance")
        genMat <-as.matrix(genMat$sampID$.base$Nei)
        
        lat_long <- sample.meta(x) |>
            select(x, y)
        
        if(i == "ALA") {
            WAcoast <- getNOAA.bathy(
                lon1 = 111.7, lon2 = 127.2,
                lat1 = -26.8, lat2 = -9.9,
                resolution = 3, 
                keep = TRUE
            )
        } else if(i == "HMA") {
            WAcoast <- getNOAA.bathy(
                lon1 = 111.7, lon2 = 127.2,
                lat1 = -26.8, lat2 = -9.9, 
                resolution = 3, keep = TRUE
            )
        } else {
            WAcoast <- getNOAA.bathy(
                lon1 = 111.7, lon2 = 127.2,
                lat1 = -26.8, lat2 = -9.9, 
                resolution = 3, 
                keep = TRUE
            )
        }
        
        transMat <- trans.mat(WAcoast) 
        lcDist <- lc.dist(transMat, lat_long, res = "dist")
        lcDist <- as.matrix(lcDist)
        
        rownames(lcDist) <- sample.meta(x)$sampID
        colnames(lcDist) <- sample.meta(x)$sampID

        # Arrange geographic distance matrix by genetic distance matrix
        lcDist <- lcDist[rownames(genMat), colnames(genMat)]

        # Grouping data into 200km bins - increases amount of data for correlation
        geo_vect <- lcDist[lower.tri(lcDist)]
        geo_classes <- cut(geo_vect, breaks = seq(0, round(max(geo_vect)), 200))
        classes <- seq(0, round( (max(lcDist, na.rm = TRUE) + 50), digits = -2 ), 200)

        # Example of running the Mantel statistic using vegan
        output.mantel <- vegan::mantel(
            as.dist(genMat),
            as.dist(lcDist),
            permutations = 10000
        )

        output.mantel.summary <- tibble(
            "Observed correlation" = output.mantel$statistic,
            "Significance" = output.mantel$signif,
            "Replicates" = output.mantel$permutations
        )

        # Correlog analysis - binned data
        output.mantel.correlog <- vegan::mantel.correlog(
            D.eco = as.dist(genMat),
            D.geo = as.dist(lcDist),
            break.pts = classes,
            nperm = 10000,
            progressive = TRUE,
            cutoff = FALSE
        )

        list(
            "mantel" = output.mantel.summary,
            "correlog" = output.mantel.correlog,
            "genetic_dist" = genMat,
            "geo_dist" = lcDist,
            "geo_classes" = geo_classes
        )
    })

mantel_results |>
    purrr::map(\(x) {
        x$mantel
    }) |>
    bind_rows(.id = "Species") |>
    gt() |>
    fmt_number(
        columns = c("Observed correlation", "Significance"),
        decimals = 4
    ) |>
    fmt_number(
        columns = "Replicates", use_seps = TRUE, drop_trailing_zeros = TRUE
    ) |>
    as_raw_html()
```

### IBD visualisation

### Geographic distance vs Genetic distance

Lastly, let's generate a scatter plot of distance vs genetic distance. Add the
correlation coefficients and p-values in Inkscape or something.

```{r IBD-correlation-plot}
df_gen_geo <- mantel_results |>
    imap(\(x, i) {
        genDist <- x[["genetic_dist"]]
        geoDist <- x[["geo_dist"]]
        
        # Reformat genetic distance matrix
        genDist[upper.tri(genDist, diag = T)] = NA
        genDist <- genDist |>
            reshape2::melt() |>
            na.omit() |>
            arrange(Var1) |>
            setNames(c("X1", "X2","GenDist")) |>
            as_tibble()
        
        # Reformat geographic distance matrix
        geoDist[upper.tri(geoDist, diag = T)] = NA
        geoDist <- geoDist |>
            reshape2::melt() |>
            na.omit() |>
            arrange(Var1) |>
            setNames(c("X1", "X2","GeoDist")) |>
            as_tibble()
        
        left_join(genDist, geoDist) |>
            na.omit()
    }) |>
    bind_rows(.id = "species") |>
    mutate(species = case_when(
        species == "ALA" ~ "Aipysurus laevis",
        species == "HMA" ~ "Hydrophis major",
        species == "HST" ~ "Hydrophis stokesii"
    ))

# Plot distance (kilometres) vs genetic distance (Nei)
plot_scatter <- df_gen_geo |>
    mutate(species = factor(species, levels = c("Aipysurus laevis", "Hydrophis major", "Hydrophis stokesii"))) |>
    ggplot(aes(x = GeoDist, y = GenDist, colour = species)) +
    geom_point(alpha = 0.4) +
    geom_smooth(mapping = aes(colour = species), method = "lm", show.legend = FALSE) +
    scale_x_continuous(
        name = "Distance (Km)",
        breaks = scales::pretty_breaks(n = 10),
        labels = scales::label_number(big.mark = ","),
        expand = c(0.01, 0, 0.02, 0)
    ) +
    scale_y_continuous(
        name = "Genetic distance (Nei)",
        breaks = scales::pretty_breaks(n = 10),
        expand = c(0.02, 0)
    ) +
    scale_colour_brewer(palette = "Set1") +
    guides(colour = guide_legend(override.aes = list(size = 6))) +
    theme(
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = "top",
        legend.text = element_text(size = 14, face = "italic"),
        legend.title = element_blank()
    )

cairo_pdf(
    here("results", "population-structure", "mantel-scatter.pdf"),
    width = 12, height = 12
)
plot_scatter
invisible(dev.off())

plot_scatter
``` 

### Spatial auto-correlation

```{r IBD-spatial-auto-correlation}
plots <- mantel_results |>
    purrr::imap(\(x, i) {
        spc <- case_when(
            i == "ALA" ~ "Aipysurus laevis",
            i == "HMA" ~ "Hydrophis major",
            i == "HST" ~ "Hydrophis stokesii"
        )
        tmp <- x$correlog$mantel.res |>
            as_tibble()
        
        tmp |>
            mutate(
                classification = case_when(
                    `Mantel.cor` < 0 & `Pr(corrected)` < 0.05 ~ "Lower",
                    `Mantel.cor` > 0 & `Pr(corrected)` < 0.05 ~ "Higher",
                    .default = "Neutral"
                ),
                classification = factor(classification, levels = c("Higher", "Neutral", "Lower"))
            ) |>
            ggplot(aes(x = class.index, y = Mantel.cor)) +
            geom_hline(yintercept = 0, colour = "red") +
            geom_line(colour = "black") +
            geom_point(
                mapping = aes(fill = classification), 
                shape = 22, 
                size = 4, 
                show.legend = TRUE, 
                colour = "black"
            ) +
            labs(
                x = "Least-cost distance (KM)",
                y = "Mantel correlation",
                fill = NULL,
                title = spc
            ) +
            scale_fill_manual(values = c("#00BA38", "grey80", "#619CFF"), drop = FALSE) +
            scale_y_continuous(
                limits = c(-0.3, 0.2),
                breaks = seq(-0.3, 0.2, 0.1),
                labels = c("0.3", "-0.2", "-0.1", "0", "0.1", "0.2"),
                expand = c(0.01, 0)
            ) +
            scale_x_continuous(
                limits = c(0, (max(tmp$class.index) + 100) ),
                breaks = seq(0, ( max(tmp$class.index) + 100), 200 ),
                labels = seq(0, ( max(tmp$class.index) + 100), 200 ),
                expand = c(0.01, 0)
            ) +
            guides(fill = guide_legend(override.aes = list(size = 6))) +
            theme(
                axis.text = element_text(size = 14),
                axis.title = element_text(size = 16),
                legend.text = element_text(size = 14),
                plot.title = element_text(face = "italic", hjust = 0.5)
            )
    })

design <- "12\n34"

plot_correlog <- plots$ALA + plots$HMA + plots$HST + guide_area() +
    plot_layout(
        design = design,
        guides = "collect",
        axes = "collect"
    )

cairo_pdf(
    here("results", "population-structure", "mantel-correlog.pdf"),
    width = 12, height = 12
)
plot_correlog
invisible(dev.off())

plot_correlog
```

### Without Shark Bay samples

```{r Load-VCF-no-SB}
meta_latLong_no_SB <- meta_latLong |>
    purrr::map(\(x) {
        x |>
            filter(pop != "Shark_Bay")
    })

# Load the VCF files as snpR data objects
vcfs_no_SB <- fs::dir_ls(
    here("results", "variant-filtering"),
    glob = "*vcf.gz",
    recurse = TRUE
) |>
    (\(x) x[str_detect(x, "HST-ld", negate = TRUE)])() |>
    (\(x) set_names(x, str_remove(basename(x), "-.*")))() |>
    imap(\(v,i) {
        tmp_vcf <- read_vcf(file = v)
        # Subset for samples to keep + add in metadata
        tmp_vcf <- subset_snpR_data(
            x = tmp_vcf, 
            .facets = "sampID",
            .subfacets = meta_latLong_no_SB[[i]]$sampID
        )
        
        sample.meta(tmp_vcf) <- left_join(sample.meta(tmp_vcf), meta_latLong_no_SB[[i]])
        
        tmp_vcf <- custom_calc_genetic_distances(
            tmp_vcf, 
            facets = c("sampID", "pop"), 
            method = "Nei"
        )
        tmp_vcf
    })
```

```{r}
mantel_results_no_SB <- vcfs_no_SB |>
    imap(\(x, i) {
        genMat <- get.snpR.stats(x, facets = "sampID", stats = "genetic_distance")
        genMat <-as.matrix(genMat$sampID$.base$Nei)
        
        long_lat <- sample.meta(x) |>
            select(x, y)
        
        if(i == "ALA") {
            WAcoast <- getNOAA.bathy(
                lon1 = 111.7, lon2 = 127.2,
                lat1 = -26.8, lat2 = -9.9,
                resolution = 3, 
                keep = TRUE
            )
        } else if(i == "HMA") {
            WAcoast <- getNOAA.bathy(
                lon1 = 111.7, lon2 = 127.2,
                lat1 = -26.8, lat2 = -9.9, 
                resolution = 3, keep = TRUE
            )
        } else {
            WAcoast <- getNOAA.bathy(
                lon1 = 111.7, lon2 = 127.2,
                lat1 = -26.8, lat2 = -9.9, 
                resolution = 3, 
                keep = TRUE
            )
        }
        
        transMat <- trans.mat(WAcoast) 
        lcDist <- lc.dist(transMat, long_lat, res = "dist")
        lcDist <- as.matrix(lcDist)
        
        rownames(lcDist) <- sample.meta(x)$sampID
        colnames(lcDist) <- sample.meta(x)$sampID
        
        # Arrange geographic distance matrix by genetic distance matrix
        lcDist <- lcDist[rownames(genMat), colnames(genMat)]
        
        # Grouping data into 200km bins - increases amount of data for correlation
        geo_vect <- lcDist[lower.tri(lcDist)]
        geo_classes <- cut(geo_vect, breaks = seq(0, round(max(geo_vect)), 200))
        classes <- seq(0, round( (max(lcDist, na.rm = TRUE) + 50), digits = -2 ), 200)
        
        # Example of running the Mantel statistic using vegan
        output.mantel <- vegan::mantel(
            as.dist(genMat),
            as.dist(lcDist),
            permutations = 10000
        )
        
        output.mantel.summary <- tibble(
            "Observed correlation" = output.mantel$statistic,
            "Significance" = output.mantel$signif,
            "Replicates" = output.mantel$permutations
        )

        # Correlog analysis - binned data
        output.mantel.correlog <- vegan::mantel.correlog(
            D.eco = as.dist(genMat),
            D.geo = as.dist(lcDist),
            break.pts = classes,
            nperm = 10000,
            progressive = TRUE,
            cutoff = FALSE
        )
        
        list(
            "mantel" = output.mantel.summary,
            "correlog" = output.mantel.correlog,
            "genetic_dist" = genMat,
            "geo_dist" = lcDist,
            "geo_classes" = geo_classes
        )
    })

mantel_results_no_SB |>
    purrr::map(\(x) {
        x$mantel
    }) |>
    bind_rows(.id = "Species") |>
    gt() |>
    fmt_number(
        columns = c("Observed correlation", "Significance"),
        decimals = 4
    ) |>
    fmt_number(
        columns = "Replicates", use_seps = TRUE, drop_trailing_zeros = TRUE
    ) |>
    as_raw_html()
```


```{r}
df_gen_geo_no_SB <- mantel_results_no_SB |>
    imap(\(x, i) {
        genDist <- x[["genetic_dist"]]
        geoDist <- x[["geo_dist"]]
        
        # Reformat genetic distance matrix
        genDist[upper.tri(genDist, diag = T)] = NA
        genDist <- genDist |>
            reshape2::melt() |>
            na.omit() |>
            arrange(Var1) |>
            setNames(c("X1", "X2","GenDist")) |>
            as_tibble()
        
        # Reformat geographic distance matrix
        geoDist[upper.tri(geoDist, diag = T)] = NA
        geoDist <- geoDist |>
            reshape2::melt() |>
            na.omit() |>
            arrange(Var1) |>
            setNames(c("X1", "X2","GeoDist")) |>
            as_tibble()
        
        left_join(genDist, geoDist) |>
            na.omit()
    }) |>
    bind_rows(.id = "species") |>
    mutate(species = case_when(
        species == "ALA" ~ "Aipysurus laevis",
        species == "HMA" ~ "Hydrophis major",
        species == "HST" ~ "Hydrophis stokesii"
    ))

# Plot distance (kilometres) vs genetic distance (Nei)
plot_scatter_no_SB <- df_gen_geo_no_SB |>
    mutate(species = factor(species, levels = c("Aipysurus laevis", "Hydrophis major", "Hydrophis stokesii"))) |>
    ggplot(aes(x = GeoDist, y = GenDist, colour = species)) +
    geom_point(alpha = 0.4) +
    geom_smooth(mapping = aes(colour = species), method = "lm", show.legend = FALSE) +
    scale_x_continuous(
        name = "Distance (Km)",
        breaks = scales::pretty_breaks(n = 10),
        labels = scales::label_number(big.mark = ","),
        expand = c(0.01, 0, 0.02, 0)
    ) +
    scale_y_continuous(
        name = "Genetic distance (Nei)",
        breaks = scales::pretty_breaks(n = 10),
        expand = c(0.02, 0)
    ) +
    scale_colour_brewer(palette = "Set1") +
    guides(colour = guide_legend(override.aes = list(size = 6))) +
    theme(
        axis.text = element_text(size = 14),
        axis.title = element_text(size = 16),
        legend.position = "top",
        legend.text = element_text(size = 14, face = "italic"),
        legend.title = element_blank()
    )

cairo_pdf(
    here("results", "population-structure", "mantel-scatter-no-shark_bay.pdf"),
    width = 12, height = 12
)
plot_scatter_no_SB
invisible(dev.off())

plot_scatter_no_SB
```

```{r}
plots_no_SB <- mantel_results_no_SB |>
    purrr::imap(\(x, i) {
        spc <- case_when(
            i == "ALA" ~ "Aipysurus laevis",
            i == "HMA" ~ "Hydrophis major",
            i == "HST" ~ "Hydrophis stokesii"
        )
        tmp <- x$correlog$mantel.res |>
            as_tibble()
        
        tmp |>
            mutate(
                classification = case_when(
                    `Mantel.cor` < 0 & `Pr(corrected)` < 0.05 ~ "Lower",
                    `Mantel.cor` > 0 & `Pr(corrected)` < 0.05 ~ "Higher",
                    .default = "Neutral"
                ),
                classification = factor(classification, levels = c("Higher", "Neutral", "Lower"))
            ) |>
            ggplot(aes(x = class.index, y = Mantel.cor)) +
            geom_hline(yintercept = 0, colour = "red") +
            geom_line(colour = "black") +
            geom_point(
                mapping = aes(fill = classification), 
                shape = 22, 
                size = 4, 
                show.legend = TRUE, 
                colour = "black"
            ) +
            labs(
                x = "Least-cost distance (KM)",
                y = "Mantel correlation",
                fill = NULL,
                title = spc
            ) +
            scale_fill_manual(values = c("#00BA38", "grey80", "#619CFF"), drop = FALSE) +
            scale_y_continuous(
                limits = c(-0.3, 0.2),
                breaks = seq(-0.3, 0.2, 0.1),
                labels = c("0.3", "-0.2", "-0.1", "0", "0.1", "0.2"),
                expand = c(0.01, 0)
            ) +
            scale_x_continuous(
                limits = c(0, (max(tmp$class.index) + 100) ),
                breaks = seq(0, ( max(tmp$class.index) + 100), 200 ),
                labels = seq(0, ( max(tmp$class.index) + 100), 200 ),
                expand = c(0.01, 0)
            ) +
            guides(fill = guide_legend(override.aes = list(size = 6))) +
            theme(
                axis.text = element_text(size = 14),
                axis.title = element_text(size = 16),
                legend.text = element_text(size = 14),
                plot.title = element_text(face = "italic", hjust = 0.5)
            )
    })

design <- "12\n34"

plot_correlog_no_SB <- plots_no_SB$ALA + plots_no_SB$HMA + plots_no_SB$HST + guide_area() +
    plot_layout(
        design = design,
        guides = "collect",
        axes = "collect"
    )

cairo_pdf(
    here("results", "population-structure", "mantel-correlog-no-shark_bay.pdf"),
    width = 12, height = 12
)
plot_correlog_no_SB
invisible(dev.off())

plot_correlog_no_SB
```


